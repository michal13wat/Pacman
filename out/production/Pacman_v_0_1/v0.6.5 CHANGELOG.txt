
WAŻNE !!!
To co dziś dodałem, jest za linią znaków "-   -   -   -   -"


Changelog zacznijcie czytać za linią znaków  "############".
Póki co to jest jeszcze wersja robocza, a nie mam dziś już siły
tego kończyć. Jutro już tak finalnie dokończę klienta i serwer
(na razie działa symulacja działania serwera).
W między czasie Janek możesz już działać.


Planowane zmiany w wersji v0.6.5:
- komunikacja klient - serwer przy pomocy Socket (nie SocketChannel)
- w dowolnym momencie serwer może komunikować się z klientami i 
  odwrotnie (a nie dopiero jak wszyscy klienci są podłączeni)
- wszyscy kliencie nadają na jednym  porcie i na drugim nasłuchują (przy serwer socket tak się da)
- każdy klient będzie musiał mieć unikatowe ID
- w momencie uruchomienia serwera odpalany jest jeden wątek nasłuchujący, na
  podłączenie się klienta kolejny jest odpalany, gdy zostaną wykonane wszystkie instrukcje
  odpalające poprzedni wątek
- klientów teoretycznie może się podłączyć nieskończona ilość, choć można zrobić jakieś tam 
  ograniczenie, aby w momencie podłączenia się wszystkich graczy pojawiał się ekran 
  typu: Wszyscy gracze podłączeni. Naciśnij start, aby rozpocząć grę (u każdego gracza się
  będzie coś takiego pojawiało i dowolny gracz może rozpocząć grę)
- z serwera do klientów przesyłane są tylko te obiekty, które się zmieniły w stosunku
  do poprzedniej (użyć obserwatorów)
- z klienta do serwera przesyłane są również tylko te obiekty które zmieniły swoją
  wartość w stosunku do poprzedniej 
  
  
Jakie klasy będą mi potrzebne:
a) w serwerze:
	- ClientThread 	- przerobić na ServerReceiver (odbieranie danych od klientów)
	- Broadcast	   	- przerobić na ServerSender (wysłanie danych do klientów)
	- ServerBrain  	- zawartość main-a wrzucić do Game-a
	- Data (po zakończonych testach wywalić to)
	
b) w kliencie:
	- BroadcastReceiver - przerobić na ClientReceiver (odbieranie danych od serwera)
	- Connection 		- przerobić na ClientSender   (wysłanie danych do serwera)
	- Data (po zakończonych testach wywalić to)
  
  
Uwaga - nie importować nigdzie pakietu server, bo z dużym prawdopodobieństwem
w wielu miejscach nazwy będą się powtarzały!!! Za każdym razem
używać pełnej ścieżki, tj.:
server. ... 

Teraz testuję przesyłanie obiektów:
1) klient -> serwer


Do zrobienia:
- jak już będzie działał klient i serwer pamiętać, żeby z powrotem przywrócić 
   uruchomienie jednego klienta lokalnie w momencie wystartowania serwera
- tym, że po kliknięciu start nie wyświetla się ekran z podłączonymi graczami,
  to nie należy się na razie przejmować. Po prostu się on nie wyświetla
  (i cały program się zawiesza), bo wtedy server czeka na jakieś dane
  od klientów, a klienci są jeszcze niezaimplementowani
  
- Czyli tak:
		Najpierw zrobić w ogóle opcję przesyłania tych obiektów klasy 
		PackToSendToServer, gdy to już będzie działało, to przerobić
		to na opcję z obserwatorem.
		
Spostrzeżenia:
- w tej implementacji komunikacji nie musimy się obawiać, ze jakieś dane
  zostaną zgubione w tej warstwie. Z tego co zauważyłem, to 
  jeżeli w danym momencie nie mogą być przesłane przez socket-a,
  to po prostu są automatycznie buforowane i czekają w kolejce na
  wysłanie
  
 
Jak będzie działało odbieranie pakietów wejściowych od klientów:
	- każdy wątek serwerowy ma jakiś tam swój bufor na dane odebrane od danego klienta
	- jeżeli bufor w kliencie jakiś w kliencie bufor zostanie zmieniony, to 
	  obserwator tej tego danego bufora zostaje powiadomiony i wrzuca zawartość tego
	  bufora na koniec kolejki w ServerBrain
	- w ServerBrain jest dwukierunkowa lista wiązana, nowe elementy są wrzucane
	  na koniec tej kolejki, elementy do przetworzenia pobierane są z początku  kolejki
	- pobierając element z tej kolejki w serwerze należy najpierw go wziąć i zaraz potem
	  usunąć.
	  
Jak będą przesyłane pakiety serwer -> klienci:
	- serwer co jakiś tam czas (np. co 20ms) będzie wysyłał do klientów ramki z danymi
	- dane przed wysłaniem będą pakowane do obiektu specjalnej klasy i wysłane.
	- przesyłane będą tylko te dane, które uległy zmianie w stosunku do poprzedniej ramki
	- w kliencie jedyny mechanizm kolejkujący odebrane dane to: socket (kolejny 
		pakiet jest odbierany z serwera dopiero, gdy poprzedni zostanie wyświetlony)
  
	- w serwerze będzie trzeba zrobić coś takiego, że kolejny obiekt będzie mógł być
	    wysłany (przypisany do zmiennej, która będzie odpowiedzialna za buforowanie obiektu 
		do wysłania) dopiero, gdy zostanie ustawiona jakaś tam flaga, że poprzedni został
		wysłany
  
    - z tego co widzę - zasadniczo procedura przesyłania przez socket-y jest taka że:
		Najpierw w kliencie muszę coś zacząć wysłać, a dopiero potem w serwerze
		powinienem to zacząć odbierać, bo inaczej serwer się zawiesza...
		
Zapamiętać sobie raz na zawsze:
 - NIGDY ALE TO PRZENIGDY NIE DEBUGOWAĆ PROGRAMU WIELOWĄTKOWEGO DEBUGEREM, TYLKO EWENUALNIE
   POPRZEZ WYPISY NA EKRAN!!!
   
   
Zalety nowego serwera w stosunku do poprzedniej wersji:
	- komunikacja odbywa się zgodnie ze sztuką (tak jak przewiduje to dokumentacjia)
	- niezależnie od tego ilu klientów jest aktualnie podłączonych komunikacjia
	  klient serwer działa cały czas
	- z klientów do serwera przesyłane są dane tylko jeżeli uległy one zmianie 
	- przy odpalonym serwerze i 4 klientach procesor jest obciążany 5-10%, w poprzeniej
	  wersji 40-50% (z wyłączoną grą!)
	- teoretycznie przesyłanie 30 fps nie powinno być dużym problemem
	- server spokojnie może wysłać różne dane do klientów, a oni nie muszą mu 
	  nic odpowiadać i w drugą stronę - działa to zupełnie niezależnie
	
Błędy które powstały w nowej wersji:
	- w sumie nie jestem pewnie jak było w poprzedniej wersji, ale w tej
	  są gubione pakiety wysłane do niektórych klientów (tylko czasami i tylko niektóre 
	  - ok 0,03% - testowane na 20.000 pakietów i 33 FPS)
	  
	  
Jak działa symulacja przetwarzania przez serwer:
	- klient wysyła do serwera jakieś tam dane (w symulacji będzie się zmieniać tylko
	  nazwa wciśniętego klawisza)
	- serwer odsyła wszystkim klientom nazwę tego klawisza + kolejne słowo z "Pana Tadeusza" :D
	
	

Do zrobienia:
	- zrobić w ServerBrain kolekcję która będzie trzymała podłączonych klientów
		zrobić wysłanie tej informacji do klientów
	- postarać się to przerobić tak, żeby wszystko co trzeba wysłać lub odebrać
	   dało się ustawić i pobrać w ClientBrain i ServerBrain
	- zrobić konfigurację serwera i klienta z poziomu okienkowego
	- napisać instrukcję jak korzystać z tej symulacji i jak to zaadaptować w grze 
	
	
	- serwer powinien wysłać tylko do klientów tylko te dane które uległy zmianie
		w stosunku do poprzedniego stanu. Niestety nie zdążę tego zrobić.
	- gdy wszyscy klienci nie są jeszcze podłączeni to co 2sek do wszystkich
		klientów niezależnie czy dane zostały zmienione czy nie 
		wysłane są wszystkie dane, ale z pustą listą klientów 
	
########################################################################################	

Skrócony opis symulacji (jak przebiega i jak to uruchomić):
	- nie spodziewajcie się, że jak klikniecie start, to
		będziecie mogli pograć :D  Uruchamianie gry 
		jest wyłączone (to jest tylko symulacja) :)
		Resztę trzeba dopisać...
		Janek - mam nadzieję, że się tym zajmiesz :)
	- aby odpalić symulację działania serwera należy najpierw włączyć serwer,
		a potem klientów (UWAGA - wywaliłem tymczasowo uruchamianie pierwszego
		klienta razem z serwerem - trzeba to zrobić oddzielnie)
	- tuż po uruchomieniu serwera i podłączeniu pierwszego klienta
		aż do czasu podłączenia wszystkich klientów, serwer co 3 sekundy
		wysyła do klientów paczkę danych. Po co? Żeby w momencie
		podłączenia nowych klientów (ekran oczekiwania na klientów -
		jeszcze nie gotowy w tej wersji serwera)
		mogła zaktualizować się ich lista.
	- gdy wszyscy klienci są już podłączeni gdy któryś z klientów
		napisze nazwę klawisza (dowolny string) jaki został wciśnięty
		zostanie przesłana ona do serwera. Tam odbywa się 
		symulacja przetwarzania (do nazwy klawisza dołączone jest
		kolejne słowo "Pana Tadeusza" :D )
	- po przetworzeniu jest to wszystko pakowane do specjalnej paczki
		i wysłane do wszystkich klientów
	- jak będziecie robić zmiany w kodzie to przejrzyjcie wszystkie
		miejsca, które oznaczyłem  //TODO
	- jak będziecie chcieli przesyłać prawdziwe obiekty gry, to
		pamiętajcie, żeby w polu _clientV2.ClientBrain.recPack
		zmienić generyczny typ wejściowy z TestObjectToSend na
		GameObject czy co to tam ma być.
		To samo tyczy się pola _serverV2.ServerBrain.packOut

Instrukcja użytkowania serwera:
	- dane odebrane przez serwer znajdują się w dwukierunkowej liście "recPacks" 
		(statyczne pole klasy _serverV2.ServerBrain)
		nowe dane odebrane od klientów są dołączone są na koniec kolejki.
		Elementy należy pobierać z początku listy
	- dane wysłane przez serwer do klientów znajdują się w obiekcie "packOut"
		(statyczne pole klasy _serverV2.ServerBrain)
	- przykład użycia danych wejściowych i wyjściowych w metodzie startServer 
		klasy Game


Instrukcja użytkowania klienta:
	- dane odebrane przez klienta znajdują się w polu _clientV2.ClientBrain.recPack
	- dane wysłane przez klienta znajdują się w polu _clientV2.ClientBrain.packOut
	- przykładowe użycie danych wejściowych i wyjściowych w wątku
		klasy ClientBrain oraz wątku klasy ClientReceiver
		
		
Do zrobienia jutro:
	- przesyłanie do klientów tylko obiektów, których wartość się zmieniła
	- konfiguracja ustawień z okienek 
	- ekran oczekiwania na graczy
	
	
-   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -	
	
	
W wielu miejscach w programie pododawałem kawałki kodu zatrzymujące
program w danym miejscu. Jako instrukcji zatrzymujących użyłem:

	if (true) return 1; 			// głównie przy wyborze MENU
	while (true) {}					// w różnych miejscach
	Thread.sleep(jakiśDługiCzas)	// też w różnych miejscach

W większość przypadków oznaczyłem te kawałki kodu
	// TODO - wywalić to
	
	
Obawiam się, że z ekranu oczekiwania na klientów będziemy musieli zrezygnować
	(wg. mnie za dużo przeróbek by to wymagało), a czasu jest zbyt mało.
Trzeba będzie zrobić prostszą wersję - gdy wszyscy kliencie są podłączeni
	po prostu jest uruchamiana gra...
Janek - jeżeli chciałbyś się jednak tym zająć - to do klasy MenuObject dopisałem
metodę updateMenuOption - działa. W klasie MenuControl w komentarzu 
masz przykład użycia tego.
   

   Znalazłem Bug-a dlaczego wcześniej nie chciało działać na kilku
   komputerach - bo adres IP był źle wczytywany.
   Był wczytywany do stringa i trzymany jako np. 127001, zamiast
	127.0.0.1  - bez kropek nie działa.
	
	
	
	
Co jeszcze nie działa:
	- lista podłączonych klientów i liczba niepodłączonych klientów nie jest
	przesyłana z serwera do klientów (wina leży po stronie serwera - 
	w ogóle nie jest ona zapełniana po stronie serwera w miarę
	podłączania się nowych klientów)
   
   
   
   


